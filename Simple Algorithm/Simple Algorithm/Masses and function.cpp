//Лекция 4
//Для массивов передаёться в функцию адреса и они меняються на прямую, для переменных рабта происходит с копиями 
//(По значению), можно изменять с помощью адресов.
//& - может быть, как бинарная (конъюнкция), а может быть как унарная - взятие адреса.
//Адрес переменной в памяти, просто число. Типа (int*)
//К адресу можно прибавить или вычесть целое число, адреса можно вычитать (если одинаковый тип), но нельзя складывать.
//Тип указателя важен, для понимания, что храниться по адресу. 
//При сложении с числом автоматически к числу применятся sizeof
//* - разъименования переменной

//Чистая фунция на Си++
//Зависит от параметров, возвращает лишь одно значение, детирминирована, не занимается вводом и выводом, не портит память.
//Для возвращения нескольких значений, можно использовать void и менять значения по адресам.
//Или можно создать койтенер (struct) с нужным количеством переменных. В С++ есть много готовых койтенеров.
//Typedef лишь создание синонима имени типа, C++ позволяет не использовать переминование и писать название без указания struct.

//-> замена для (*p).a для указателя на структуру, . для самой стуктуры
//sizeof - показывает вес определённого типа

//Реинтропретация данных
//x = *(int64_t*)(&y)
//x - int64_t; y - double;
//x = *reinterpret_cast<int64_t*>(&y);

//x = *static_cast<int64_t*>(&y); - есть такой спопсоб, но не для этого случая.


//Массив - структура данных фиксированного размера с однотипными эл-тами
//оперативно доступных по индексу. (за O(1)). A[i]. 
//A[0] - тот же указатель на массив
//Если мы заведём переменную p как указатель на массив, то разъименовав его будем иметь указатель на A[0].
//С помощью адресной арифметики можно будет двигать указатель дальше по массиву
//например p += 1; Смещение на 1.
//или *(p+i) -> указвает на индекс (*(A+i))==A[i]

//Сущесвтуют ошибки segmentation fald - выход за границы выделенной на программу памяти
//и undefine behaviour - зацикливение в результате постоянного попадания на ячейку памяти индекса в цикле
//в результате выхода за гриницу массива

//Можно 2[A] - но не стоит

//Решето Эратосфера
//Начиная от двойки и далее до счётного числа N.
//Выбираю двойку минимальным простым число, и далее с шагом два 
//вычёркиваю все числа, кратные двум
//Беру следующее незачёркнутое число и повторяю алгоритм.
//и так далее пока не будет всех не зачёркнутых. (Можно начинать зачёркивать от (простое в квадрате))
//#include <iostream>
//
//using namespace std;
//
//int main()
//{
//	//int n;
//	//std::cin >> n;
//	//bool sieve[n + 1];
//	bool sieve[20 + 1]; //0 and 1 not prime and composite
//	int n = 20;
//	for (int i = 2; i < n + 1; i++)
//	{
//		sieve[i] = true;
//	}
//	int x = 2;
//	while (x * x <= n) {
//		if (sieve[x]) {
//			for (int y = x * x; y <= n; y += x) {
//				sieve[y] = false; //composite
//			}
//		}
//		x += 1;
//	}
//
//	for (int i = 2; i < n + 1; i++)
//	{
//		if (sieve[i]) {
//			std::cout << i << '\t';
//		}
//	}
//	std::cout << '\n';
//	return 0;
//}

